https://geant4-forum.web.cern.ch/t/last-step-in-a-volume/856/12//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
// Author: Chad Lantz

#include "FiberSD.hh"
#include "SteppingAction.hh"
#include "AnalysisManager.hh"

#include "G4HCofThisEvent.hh"
#include "G4Step.hh"
#include "G4ThreeVector.hh"
#include "G4UImanager.hh"
#include "G4SDManager.hh"
#include "G4ios.hh"
#include "G4Poisson.hh"
#include "G4ParticleTypes.hh"
#include "G4ParticleDefinition.hh"
#include "G4SystemOfUnits.hh"

#include <string>
#include <iostream>
#include <cmath>

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

FiberSD::FiberSD(G4String sdName, G4int modNum, G4bool optical)
  :G4VSensitiveDetector(sdName),
  m_modNum(modNum),
  OPTICAL(optical),
  REDUCED_TREE(false),
  ZDC(false),
  RPD(false),
  VISUALIZE(false){
  collectionName.insert(sdName);
  HCID = -1;

  if( sdName.contains("R") ) RPD = true;
  if( sdName.contains("Z") ) ZDC = true;

  m_nSteps = 1;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

FiberSD::~FiberSD(){ }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void FiberSD::HistInitialize(){
  std::string name = GetName();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void FiberSD::Initialize(G4HCofThisEvent* HCE){

  fiberCollection = new FiberHitsCollection(SensitiveDetectorName,
					      m_modNum);

  std::string name = collectionName[0];

  // Grab output vectors from AnalysisManager
  m_analysisManager = AnalysisManager::getInstance();
  m_analysisManager->GetSDvectors( ZDC, RPD, m_modNum, &m_intVec, &m_dblVec );
  // G4cout << GetName() << " intVec is " << m_intVec->size() << ", dblVec is " << m_dblVec->size() << " long" << G4endl;

  // Resize the histogram vector
  if(REDUCED_TREE){
    m_intVec->at(0).resize( m_nFibers, 0 );
    m_intVec->at(1).resize( 128*m_nSegments, 0 );
  }

  // If the UI window exists, set visualize to true so we record and draw hits
  if( G4UImanager::GetUIpointer()->GetG4UIWindow() ) VISUALIZE = true;

  m_nCherenkovs = m_nCherenkovsThisTrack = m_nHits = 0;

  if(HCID<0)
    { HCID = G4SDManager::GetSDMpointer()->GetCollectionID( name );}

  HCE->AddHitsCollection( HCID, fiberCollection );
  G4cout << " HCID " << HCID << " name " << name << G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

G4bool FiberSD::ProcessHits(G4Step* aStep,G4TouchableHistory*){

  //Get the number of Cherenkov photons created in this step
  int capturedPhotons = 0;
  const std::vector<const G4Track*>* secVec = aStep->GetSecondaryInCurrentStep();
  for(uint i = 0; i < secVec->size(); i++){
    if( secVec->at(i)->GetDefinition() == G4OpticalPhoton::OpticalPhotonDefinition()){
      capturedPhotons++;
    }//end if photon
  }//end secondary track loop
  m_nCherenkovs += capturedPhotons; // Record the total in case OPTICAL is true

  G4int rodNum = aStep->GetPreStepPoint()->GetTouchableHandle()->GetCopyNumber(0);

  G4ThreeVector pos = aStep->GetTrack()->GetPosition();
  G4ThreeVector momentum = aStep->GetTrack()->GetMomentum();
  G4double energy = aStep->GetPreStepPoint()->GetTotalEnergy();
  G4double time = aStep->GetPreStepPoint()->GetGlobalTime();
  G4ParticleDefinition *particle = aStep->GetTrack()->GetDefinition();

  //Display everything if the UI is on
  if(VISUALIZE){
    FiberHit* newHit = new FiberHit();
    newHit->setPos( pos );
    fiberCollection->insert ( newHit );
  }

  // If OPTICAL is true, determine if the photon has reached the top of the topOfVolume
  // and add the hit to the collection if it has
  if(OPTICAL){
    if( aStep->GetTrack()->GetDefinition() == G4OpticalPhoton::OpticalPhotonDefinition() && pos.y() >= m_topOfVolume - 0.1*mm){
      if(REDUCED_TREE){
        m_intVec->at(0)[rodNum]++;
        FillTimeVector( rodNum, time );

        m_nHits++;
        return true;
      }

      m_intVec->at(0).push_back( rodNum );

      G4ThreeVector origin = aStep->GetTrack()->GetVertexPosition();
      m_dblVec->at(0).push_back( origin.x()   );
      m_dblVec->at(1).push_back( origin.y()   );
      m_dblVec->at(2).push_back( origin.z()   );
      m_dblVec->at(3).push_back( momentum.x() );
      m_dblVec->at(4).push_back( momentum.y() );
      m_dblVec->at(5).push_back( momentum.z() );
      m_dblVec->at(6).push_back( time         );

      aStep->GetTrack()->SetTrackStatus( fStopAndKill ); //Kill the track so we only record it once
      return true;
    }
  }else{ //!OPTICAL

    //We have found that generated cherenkov photons seem to take a step while the mother track is
    //still alive. Check here for that photon and skip over it if it shows up.
    if( aStep->GetTrack()->GetDefinition() == G4OpticalPhoton::OpticalPhotonDefinition() ){
      return true;
    }

    //Sum the number of generated cherenkov photons and energy deposited for each step
    //within this volume.
    m_nCherenkovsThisTrack += capturedPhotons;
    m_eDepThisTrack += aStep->GetTotalEnergyDeposit();

    if (rodNum == 330  && m_nCherenkovsThisTrack != 0 && pos.z() < 100.)    std::cout << "nCherenkovs!!!!! : " << m_nCherenkovsThisTrack << " trackID " << aStep->GetTrack()->GetTrackID() << " rodNum " << rodNum << " pid " << particle->GetPDGEncoding() << " nSteps " << m_nSteps << " IsLastStepInVolume " << aStep->IsLastStepInVolume() << " TrackStatus  " << aStep->GetTrack()->GetTrackStatus() << " X: " << pos.x() << " Y: " << pos.y() << " Z: " << pos.z() << std::endl;
    
    //If this is not that particle's last step in the volume and it has not died,
    //return and wait for its next step
    if( !aStep->IsLastStepInVolume() && aStep->GetTrack()->GetTrackStatus() != fStopAndKill ){
      ++m_nSteps;
      return true;
    }
    if (rodNum == 330 && m_nCherenkovsThisTrack != 0 && pos.z() < 100.)    std::cout << "WRITING HIT!!!!!! nCherenkovs TOTAL : " << m_nCherenkovsThisTrack << " trackID " << aStep->GetTrack()->GetTrackID() << " rodNum " << rodNum << " pid " << particle->GetPDGEncoding() << " nSteps " << m_nSteps << std::endl;
    if(REDUCED_TREE){
      m_intVec->at(0)[rodNum] += capturedPhotons;
      FillTimeVector( rodNum, aStep->GetTrack()->GetGlobalTime(), m_nCherenkovsThisTrack );

      m_nHits++;
      return true;
    }

    m_dblVec->at(0). push_back( pos.x() );
    m_dblVec->at(1). push_back( pos.y() );
    m_dblVec->at(2). push_back( pos.z() );
    m_dblVec->at(3). push_back( momentum.x() );
    m_dblVec->at(4). push_back( momentum.y() );
    m_dblVec->at(5). push_back( momentum.z() );
    m_dblVec->at(6). push_back( energy       );
    m_dblVec->at(7). push_back( aStep->GetTrack()->GetVelocity()                );
    m_dblVec->at(8). push_back( aStep->GetTrack()->GetVelocity()/CLHEP::c_light );
    m_dblVec->at(9). push_back( m_eDepThisTrack                                 );
    m_dblVec->at(10).push_back( aStep->GetPreStepPoint()->GetCharge()           );
    m_dblVec->at(11).push_back( time );

    m_intVec->at(0).push_back( rodNum                 );
    m_intVec->at(1).push_back( m_nCherenkovsThisTrack );
    m_intVec->at(2).push_back( aStep->GetTrack()->GetTrackID() );
    m_intVec->at(3).push_back( particle->GetPDGEncoding()      );

    //Reset the counters for the next track
    m_nCherenkovsThisTrack = 0;
    m_eDepThisTrack = 0.0;
    m_nSteps = 1;
    return true;
  }

  return false; //Something failed if we got here
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void FiberSD::EndOfEvent(G4HCofThisEvent*)
{
  char message[128];
  int nHits = (REDUCED_TREE) ? m_nHits : m_intVec->at(0).size();

  if(OPTICAL){
    if(!REDUCED_TREE) m_analysisManager->FillnCherenkovsCol( ZDC, RPD, m_modNum, m_nCherenkovs );
    sprintf(message,"%s nOpticalHits = %d", GetName().c_str(), nHits );
  }else{
    sprintf(message,"%s nHits = %d", GetName().c_str(), nHits );
  }

  G4cout << message << G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void FiberSD::SetReducedTree ( G4int _nFibers, G4int _nSegments ){
  REDUCED_TREE = true;
  m_nFibers = _nFibers;
  m_nSegments = _nSegments;
  m_nFibersPerSegment = _nFibers/_nSegments;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void FiberSD::FillTimeVector( G4int fiberNo, G4double time, G4int weight ){
  // This vector consists of nSegments number of "histograms" each 128 bins long, covering 64ns
  // concatenated in order of segment number (fiber number/m_nFibersPerSegment a.k.a. Channel)

  int bin = (time <= 64*ns) ? time/0.5 : 127;  // Determine the bin for this segments histo
  int offset = fiberNo/m_nFibersPerSegment;    // Do this because there was a rounding issue when just using an int cast
  bin += 128*offset;                           // Add the offset for the current segment (channel)
  m_intVec->at(1)[bin] += weight;                // Add the weight (nPhotons).
}
